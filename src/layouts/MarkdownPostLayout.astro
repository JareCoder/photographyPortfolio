---
import BaseLayout from "./BaseLayout.astro";
import "../styles/glightbox.css";
import Prose from "../components/Prose.astro";
import { getImage, Image } from "astro:assets";
const { frontmatter } = Astro.props;
const updatedDate = frontmatter?.updatedDate
  .toDateString()
  .split(" ")
  .slice(1)
  .join(" ");
const publishedDate = frontmatter?.pubDate
  .toDateString()
  .split(" ")
  .slice(1)
  .join(" ");
const title = frontmatter?.title;
const description = frontmatter?.description;
// const author = frontmatter?.author.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
const authorFullName = frontmatter?.author;
const author = authorFullName.split(" ")[0].toLowerCase();
const image = frontmatter.image?.src;
const alt = frontmatter.image?.alt;
const positionx = frontmatter?.image?.positionx;
const positiony = frontmatter?.image?.positiony;

let baseUrl = new URL(Astro.request.url).origin;

const imageObj = image
  ? await getImage({
      src: image,
      inferSize: true,
      widths: [1280, 1920, 2560, 3840],
      heights: [720, 1080, 1440, 2160],
      sizes: "(max-width: 1280px) 1280px, (max-width: 1920px) 1920px, (max-width: 2560px) 2560px, 3840px",
      decoding: "async",
      alt: alt,
      format: "avif",
    })
  : null;
---

<BaseLayout
  title={title}
  image={image ? `${baseUrl}${imageObj?.src}` : ""}
  alt={alt ? imageObj?.attributes.alt : ""}
  description={description}
  author={author}
  pubDate={updatedDate}
  updatedDate={publishedDate}
  is404Page={false}
>
  {
    image ? (
      <div
        id="backgroundImageContainer"
        class="relative h-screen mb-8 md:-mx-16 -mx-8 overflow-hidden"
        data-pagefind-body
      >
        <div class="parallax-container">
          <Image
            src={imageObj.src}
            width={imageObj.attributes.width}
            height={imageObj.attributes.height}
            alt={imageObj.attributes.alt || alt}
            class="parallax-bg"
            sizes={imageObj.attributes.sizes}
            data-pagefind-meta="image[src]"
            data-positionx={positionx}
            data-positiony={positiony}
          />
        </div>
        <div class="relative flex flex-col justify-center items-center text-center h-full">
          <h1 class="prose prose-slate uppercase font-overpass-mono text-[rgb(245,245,245)] text-4xl">
            {title}
          </h1>
          <div class="flex gap-2 mt-2">
            {frontmatter.tags.map((tag) => (
              <p class="font-overpass-mono text-xl">
                <a
                  class="bg-slate-600 text-[rgb(245,245,245)] bg-opacity-50 px-2 py-1 rounded"
                  href={`../tags/${tag}`}
                >
                  {tag}
                </a>
              </p>
            ))}
          </div>
        </div>
      </div>
    ) : (
      <div data-pagefind-body>
        <Prose>
          <h1 class="normal-case font-overpass-mono text-4xl -mb-1 mt-4">
            {title}
          </h1>
          <div class="flex">
            {frontmatter.tags.map((tag) => (
              <p class="font-overpass-mono text-xl">
                <a
                  class="bg-slate-600 text-[rgb(245,245,245)] bg-opacity-50 px-2 py-1 rounded no-underline"
                  href={`../tags/${tag}`}
                >
                  {tag}
                </a>
              </p>
            ))}
          </div>
        </Prose>
      </div>
    )
  }
  <div data-pagefind-body>
    <Prose>
      <slot />
      <div class="flex flex-col sm:flex-row align-center">
        <div class="w-full flex-col sm:w-1/2 text-center sm:text-left">
          <p>
            -- <a
              href={`/authors/${author}`}
              class="no-underline font-inconsolata"
            >
              {authorFullName}</a
            >
          </p>
        </div>
        <div
          class="w-full flex-col sm:w-1/2 text-left sm:text-right mt-[10px] font-inconsolata"
        >
          <div>
            Published: {publishedDate}
          </div>
          <div>
            Updated: {updatedDate}
          </div>
        </div>
      </div>
    </Prose>
  </div>
</BaseLayout>
<style>
  .parallax-wrapper {
    position: absolute;
    inset: 0;
    overflow: hidden;
  }
  .parallax-bg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    will-change: transform;
    transform: translateY(0);
    /* Use translate3d for hardware acceleration */
    transform: translate3d(0, 0, 0);
  }
  @media (max-width: 800px) {
    .parallax-bg {
      object-position: var(--positionx, 50%) var(--positiony, 50%);
    }
  }
</style>

<script>
  document.addEventListener("astro:page-load", () => {
    const container = document.querySelector("#backgroundImageContainer");
    const bg = document.querySelector(".parallax-bg");
    let rafId = null;

    function setImagePosition() {
      if (bg) {
        bg.style.setProperty("--positionx", bg.dataset.positionx || "50%");
        bg.style.setProperty("--positiony", bg.dataset.positiony || "50%");
      }
    }

    function updateParallax() {
      if (bg && container) {
        const rect = container.getBoundingClientRect();
        const scrollY = window.scrollY;
        const offset = (scrollY - rect.top) * 0.3;

        bg.style.transform = `translate3d(0, ${offset.toFixed(2)}px, 0)`;
      }
      rafId = null;
    }

    function requestUpdate() {
      if (rafId === null) {
        rafId = requestAnimationFrame(updateParallax);
      }
    }

    setImagePosition();

    const throttledResize = throttle(setImagePosition, 100);

    window.addEventListener("resize", throttledResize);
    window.addEventListener("scroll", requestUpdate);

    // Initial update
    updateParallax();

    return () => {
      window.removeEventListener("resize", throttledResize);
      window.removeEventListener("scroll", requestUpdate);
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
      }
    };
  });

  function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function () {
      const context = this;
      const args = arguments;
      if (!lastRan) {
        func.apply(context, args);
        lastRan = Date.now();
      } else {
        clearTimeout(lastFunc);
        lastFunc = setTimeout(
          function () {
            if (Date.now() - lastRan >= limit) {
              func.apply(context, args);
              lastRan = Date.now();
            }
          },
          limit - (Date.now() - lastRan),
        );
      }
    };
  }
</script>
